{"posts":[{"title":"SpringBoot 热插拔技术","content":"还记得我们经常会在启动类Application上面加@EnableXXX注解吗？ 其实这个@Enablexxx注解就是一种热拔插技术，加了这个注解就可以启动对应的starter，当不需要对应的starter的时候只需要把这个注解注释掉就行，是不是很优雅呢？那么这是如何实现的呢？ 新增标记类ConfigMarkerpublic class ConfigMarker { } 新增EnableRegisterServer注解@Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Import({ConfigMarker.class}) public @interface EnableRegisterServer { } 改造 MyAutoConfiguration 新增条件注解 @ConditionalOnBean(ConfigMarker.class) ，@ConditionalOnBean 这个是条件注解，前面的意思代表只有当期上下文中含有 ConfigMarker对象，被标注的类才会被实例化。@Configuration @ConditionalOnBean(ConfigMarker.class) public class MyAutoConfiguration { static { System.out.println(&quot;MyAutoConfiguration init....&quot;); } @Bean public SimpleBean simpleBean(){ return new SimpleBean(); } } 改造service工程 在启动类上新增@EnableImRegisterServer注解 到此热插拔就实现好了，当你加了 @EnableImRegisterServer 的时候启动zdy工程就会自动装配 SimpleBean，反之则不装配。 原理也很简单，当加了 @EnableImRegisterServer 注解的时候，由于这个注解使用了 @Import({ConfigMarker.class}) ，所以会导致Spring去加载 ConfigMarker 到上下文中，而又因为条件注解 @ConditionalOnBean(ConfigMarker.class) 的存在，所以MyAutoConfiguration 类就会被实例化。 关于条件注解的讲解 @ConditionalOnBean：仅仅在当前上下文中存在某个对象时，才会实例化一个Bean。 @ConditionalOnClass：某个class位于类路径上，才会实例化一个Bean。 @ConditionalOnExpression：当表达式为true的时候，才会实例化一个Bean。基于SpEL表达式的条件判断。 @ConditionalOnMissingBean：仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean。 @ConditionalOnMissingClass：某个class类路径上不存在的时候，才会实例化一个Bean。 @ConditionalOnNotWebApplication：不是web应用，才会实例化一个Bean。 @ConditionalOnWebApplication：当项目是一个Web项目时进行实例化。 @ConditionalOnNotWebApplication：当项目不是一个Web项目时进行实例化。 @ConditionalOnProperty：当指定的属性有指定的值时进行实例化。 @ConditionalOnJava：当JVM版本为指定的版本范围时触发实例化。 @ConditionalOnResource：当类路径下有指定的资源时触发实例化。 @ConditionalOnJndi：在JNDI存在的条件下触发实例化。 @ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。 ","link":"https://promonkeylee.github.io/post/springboot-re-cha-ba-ji-zhu/"},{"title":"Dubbo配置项说明","content":"1.dubbo:application 对应 org.apache.dubbo.config.ApplicationConfig, 代表当前应用的信息 name: 当前应用程序的名称，在dubbo-admin中我们也可以看到，这个代表这个应用名称。我们在真正时是时也会根据这个参数来进行聚合应用请求。 owner: 当前应用程序的负责人，可以通过这个负责人找到其相关的应用列表，用于快速定位到责任人。 qosEnable : 是否启动QoS 默认true qosPort : 启动QoS绑定的端口 默认22222 qosAcceptForeignIp: 是否允许远程访问 默认是false 2.dubbo:registry org.apache.dubbo.config.RegistryConfig, 代表该模块所使用的注册中心。一个模块中的服务可以将其注册到多个注册中心上，也可以注册到一个上。后面再service和reference也会引入这个注册中心。 id : 当当前服务中provider或者consumer中存在多个注册中心时，则使用需要增加该配置。在一些公司，会通过业务线的不同选择不同的注册中心，所以一般都会配置该值。 address : 当前注册中心的访问地址。 protocol : 当前注册中心所使用的协议是什么。也可以直接在 address 中写入，比如使用zookeeper，就可以写成 zookeeper://xx.xx.xx.xx:2181 timeout : 当与注册中心不再同一个机房时，大多会把该参数延长。 3.dubbo:protocol org.apache.dubbo.config.ProtocolConfig, 指定服务在进行数据传输所使用的协议。 id : 在大公司，可能因为各个部门技术栈不同，所以可能会选择使用不同的协议进行交互。这里在多个协议使用时，需要指定。 name : 指定协议名称。默认使用 dubbo 。 4. dubbo:service org.apache.dubbo.config.ServiceConfig, 用于指定当前需要对外暴露的服务信息，后面也会具体讲解。和 dubbo:reference 大致相同。 interface : 指定当前需要进行对外暴露的接口是什么。 ref : 具体实现对象的引用，一般我们在生产级别都是使用Spring去进行Bean托管的，所以这里面一般也指的是Spring中的BeanId。 version : 对外暴露的版本号。不同的版本号，消费者在消费的时候只会根据固定的版本号进行消费。 5.dubbo:reference org.apache.dubbo.config.ReferenceConfig, 消费者的配置，这里只做简单说明，后面会具体讲解。 id : 指定该Bean在注册到Spring中的id。 interface: 服务接口名 version : 指定当前服务版本，与服务提供者的版本一致。 registry : 指定所具体使用的注册中心地址。这里面也就是使用上面在 dubbo:registry 中所声明的id。 6.dubbo:method org.apache.dubbo.config.MethodConfig, 用于在制定的 dubbo:service 或者dubbo:reference 中的更具体一个层级，指定具体方法级别在进行RPC操作时候的配置，可以理解为对这上面层级中的配置针对于具体方法的特殊处理。 name : 指定方法名称，用于对这个方法名称的RPC调用进行特殊配置。 async: 是否异步 默认false 7.dubbo:service和dubbo:reference详解 这两个在dubbo中是我们最为常用的部分，其中有一些我们必然会接触到的属性。并且这里会讲到一些设置上的使用方案。 mock: 用于在方法调用出现错误时，当做服务降级来统一对外返回结果，后面我们也会对这个方法做更多的介绍。 timeout: 用于指定当前方法或者接口中所有方法的超时时间。我们一般都会根据提供者的时长来具体规定。比如我们在进行第三方服务依赖时可能会对接口的时长做放宽，防止第三方服务不稳定导致服务受损。 check: 用于在启动时，检查生产者是否有该服务。我们一般都会将这个值设置为false，不让其进行检查。因为如果出现模块之间循环引用的话，那么则可能会出现相互依赖，都进行check的话，那么这两个服务永远也启动不起来。 retries: 用于指定当前服务在执行时出现错误或者超时时的重试机制。 注意提供者是否有幂等，否则可能出现数据一致性问题 注意提供者是否有类似缓存机制，如出现大面积错误时，可能因为不停重试导致雪崩 executes: 用于在提供者做配置，来确保最大的并行度。 可能导致集群功能无法充分利用或者堵塞 但是也可以启动部分对应用的保护功能 可以不做配置，结合后面的熔断限流使用 ","link":"https://promonkeylee.github.io/post/dubbo-pei-zhi-xiang-shuo-ming/"},{"title":"Zookeeper服务启动","content":"Zookeeper服务器的启动，⼤致可以分为以下五个步骤 配置⽂件解析 初始化数据管理器 初始化⽹络I/O管理器 数据恢复 对外服务 单机版服务器启动 1. 预启动 2. 初始化 集群服务器启动 1. 预启动 2. 初始化 3. Leader选举 4. Leader和Follower启动期交互过程 1. 创建Leader服务器和Follower服务器。完成Leader选举后，每个服务器会根据自己服务器的角色创建相应的服务器实例，并进入各自角色的主流程。 2. Leader服务器启动Follower接收器LearnerCnxAcceptor。运行期间， Leader服务器需要和所有其余的服务器（统称为Learner）保持连接以确集群的机器存活情况， LearnerCnxAcceptor负责接收所有非Leader服务器的连接请求。 3. Learner服务器开始和Leader建立连接。所有Learner会找到Leader服务器，并与其建立连接。 4. Leader服务器创建LearnerHandler。 Leader接收到来自其他机器连接创建请求后，会创建一个LearnerHandler实例，每个LearnerHandler实例都对应一个Leader与Learner服务器之间的连接，其负责Leader和Learner服务器之间几乎所有的消息通信和数据同步。 5. 向Leader注册。 Learner完成和Leader的连接后，会向Leader进行注册，即将Learner服务器的基本信息（LearnerInfo），包括SID和ZXID，发送给Leader服务器。 6. Leader解析Learner信息，计算新的epoch。 Leader接收到Learner服务器基本信息后，会解析出该Learner的SID和ZXID，然后根据ZXID解析出对应的epoch_of_learner，并和当前Leader服务器的epoch_of_leader进行比较，如果该Learner的epoch_of_learner更大，则更新Leader的epoch_of_leader = epoch_of_learner + 1。然后LearnHandler进行等待，直到过半Learner已经向Leader进行了注册，同时更新了epoch_of_leader后， Leader就可以确定当前集群的epoch了。 7. 发送Leader状态。计算出新的epoch后， Leader会将该信息以一个LEADERINFO消息的形式发送给Learner，并等待Learner的响应。 8. Learner发送ACK消息。 Learner接收到LEADERINFO后，会解析出epoch和ZXID，然后向Leader反馈一个ACKEPOCH响应。 9. 数据同步。 Leader收到Learner的ACKEPOCH后，即可进行数据同步。 10. 启动Leader和Learner服务器。当有过半Learner已经完成了数据同步，那么Leader和Learner服务器实例就可以启动了。 5. Leader和Follower启动 1. 创建启动会话管理器。 2. 初始化Zookeeper请求处理链，集群模式的每个处理器也会在启动阶段串联请求处理链。 3. 注册JMX服务。 ","link":"https://promonkeylee.github.io/post/zookeeper-fu-wu-qi-dong/"},{"title":"架构设计基本原则","content":"1. 开闭原则 1.1 开闭原则的定义 开闭原则：软件实体应当对扩展开放，对修改关闭，这就是开闭原则的经典定义。 这里的软件实体包括以下几个部分： 项目中划分出的模块 类与接口 方法 **开闭原则的含义是：**当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 1.2 开闭原则的作用 开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。 对软件测试的影响 可以提高代码的可复用性 可以提高软件的可维护性 1.3 开闭原则的实现方法 可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 举例: 学校有许多的课程，其中有一门课程为java课程，我们需要打印出该课程的id、名称以及售价,为此新建一个接口类ICourse和实现类JavaCourse，JavaCourse实现接口ICours 此时，正好赶上节日，我们有一个促销活动，JAVA课程我们打六折 第一种选择: 在ICours新增打折方法getDiscountPrice, 这种会将所有实现ICours接口的实现类都得做改变 第二种选择： 每次打折我们都修改JavaCourse类,这种代码显然是不合理的，这样破坏了原本稳定的代码 第三种选择： 新建一个JavaDiscountCourse类继承JavaCourse，并在JavaDiscountCourse新增加一个打折 即可 2. 单一职责原则 2.1 单一职责原则的定义 单一职责原则又称单一功能原则，这里的职责是指类变化的原因，单一职责原则规定一个类应该有 且仅有一个引起它变化的原因，否则类应该被拆分。 该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 2.2 单一职责原则的优点 单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。 降低类的复杂度 提高类的可读性 提高系统的可维护性 变更引起的风险降低 2.3 单一职责原则的实现方法 单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。 大学学生工作管理程序: 3.接口隔离原则 3.1 接口隔离原则的定义 接口隔离原则要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 ** 3.2接口隔离原则的优点** 接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。 提高系统的灵活性和可维护性 降低系统的耦合性。 保证系统的稳定性 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余 3.3 接口隔离原则的实现方法 在具体应用接口隔离原则时，应该根据以下几个规则来衡量。 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 举例: 学生成绩管理程序学, 学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均 分、打印成绩信息、査询成绩信息等功能， 如果将这些功能全部放到一个接口中显然不太合理 正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中 4.里氏替换原则 4.1里氏替换原则的定义 里氏替换原则主要阐述了有关继承的一些原则。里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。总结:子类可以扩展父类的功能，但不能改变父类原有的功能 4.2 里氏替换原则的作用 里氏替换原则的主要作用如下。 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。 4.3里氏替换原则的实现方法 根据上述理解，对里氏替换原则的定义可以总结如下： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类中可以增加自己特有的方法 5.依赖倒置原则 5.1 依赖倒置原则定义 依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依 赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。 5.2依赖倒置原则的作用 依赖倒置原则的主要作用如下。 可以降低类间的耦合性。 可以提高系统的稳定性。 可以减少并行开发引起的风险。 可以提高代码的可读性和可维护性 5.3 依赖倒置原则的实现方法 依赖倒置原则在“顾客购物程序”中的应用 本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以 下代码定义了顾客类通过韶关网店 ShaoguanShop 购物： class Customer { public void shopping(ShaoguanShop shop) { //购物 System.out.println(shop.sell()); } } 但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下： class Customer { public void shopping(WuyuanShop shop) { //购物 System.out.println(shop.sell()); } } 顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是： 顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。 class Customer { public void shopping(Shop shop) { //购物 System.out.println(shop.sell()); } } 6.迪米特法则 6.1迪米特法则的定义 迪米特法则又叫作最少知识原则, 迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 6.2迪米特法则的优点 迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用性和系统的扩展性 6.3迪米特法则的实现方法 从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法。 案例:明星与经纪人的关系实例 分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则 //经纪人 class Agent { private Star myStar; private Fans myFans; private Company myCompany; public void setStar(Star myStar) { this.myStar = myStar; } public void setFans(Fans myFans) { this.myFans = myFans; } public void setCompany(Company myCompany) { this.myCompany = myCompany; } public void meeting() { System.out.println(myFans.getName() + &quot;与明星&quot; + myStar.getName() + &quot;见面了。&quot;); } public void business() { System.out.println(myCompany.getName() + &quot;与明星&quot; + myStar.getName() + &quot;洽淡业务。&quot;); } } //明星 class Star { private String name; Star(String name) { this.name = name; } public String getName() { return name; } } //粉丝 class Fans { private String name; Fans(String name) { this.name = name; } public String getName() { return name; } } //媒体公司 class Company { private String name; Company(String name) { this.name = name; } public String getName() { return name; } } package principle; public class LoDtest { public static void main(String[] args) { Agent agent = new Agent(); agent.setStar(new Star(&quot;林心如&quot;)); agent.setFans(new Fans(&quot;粉丝韩丞&quot;)); agent.setCompany(new Company(&quot;中国传媒有限公司&quot;)); agent.meeting(); agent.business(); } } 7.合成复用原则 7.1合成复用原则的定义 合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则 （Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的， 两者都是开闭原则的具体实现规范。 7.2合成复用原则的重要性 通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性 子类与父类的耦合度高 它限制了复用的灵活性 采用合成复用原则时，他可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已 有对象的功能，它有以下优点。 它维持了类的封装性 新旧类之间的耦合度低 复用的灵活性高 7.3合成复用原则的实现方法 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已 有对象的功能，从而达到复用。 下面以汽车分类管理程序为例来介绍合成复用原则的应用。 分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。 所示是用继承关系实现的汽车分类的类图。 从上图 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题 ","link":"https://promonkeylee.github.io/post/jia-gou-she-ji-ji-ben-yuan-ze/"},{"title":"分布式理论","content":"什么是分布式系统 分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。 通俗的理解，所谓分布式系统，就是一个业务拆分成多个子业务，分布在不同的服务器节点，共同构成的系统称为分布式系统，同一个分布式系统中的服务器节点在空间部署上是可以随意分布的，这些服务器可能放在不同的机柜中，也可能在不同的机房中，甚至分布在不同的城市。 分布式与集群的区别 集群: 多个服务器做同一个事情 分布式: 多个服务器做不同的事情 分布式系统特性 分布性 空间中随机分布。这些计算机可以分布在不同的机房，不同的城市，甚至不同的国家。 对等性 分布式系统中的计算机没有主/从之分，组成分布式系统的所有节点都是对等的。 并发性 同一个分布式系统的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储。 缺乏全局时钟 既然各个计算机之间是依赖于交换信息来进行相互通信，很难定义两件事件的先后顺序，缺乏全局始终控制序列 故障总会发生 组成分布式的计算机，都有可能在某一时刻突然间崩掉。分的计算机越多，可能崩掉一个的几率就越大。如果再考虑到设计程序时的异常故障，也会加大故障的概率。 处理单点故障 单点SPoF（Single Point of Failure）：某个角色或者功能只有某一台计算机在支撑，在这台计算机上出现的故障是单点故障 分布式系统面临的问题 通信异常 网络分区 节点故障 三态(成功、失败和超时) 重发 幂等 数据一致性 强一致性 弱一致性 最终一致性 因果一致性 读己之所写一致性 会话一致性 单调读一致性 单调写一致性 一致性模型图 CAP定理 CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点 选项 具体意义 一致性（Consistency） 所有节点访问时都是同一份最新的数据副本 可用性（Availability） 每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据 分区容错性（Partitiontolerance） 分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障 ","link":"https://promonkeylee.github.io/post/fen-bu-shi-li-lun/"},{"title":"RPC框架","content":"分布式架构网络通信 在分布式服务框架中，一个最基础的问题就是远程服务是怎么通讯的，在Java领域中有很多可实现远程通讯的技术，例如：RMI、Hessian、SOAP、ESB和JMS等，它们背后到底是基于什么原理实现的呢？ 基本原理 要实现网络机器间的通讯，首先得来看看计算机系统网络通信的基本原理，在底层层面去看，网络通信需要做的就是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、aio三种方式，所有的分布式应用通讯都基于这个原理而实现 什么是RPC RPC全称为remote procedure call，即远程过程调用。借助RPC可以做到像本地调用一样调用远程服 务，是一种进程间的通信方式. 比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。 RPC架构 一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。 客户端(Client)，服务的调用方。 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。 服务端(Server)，真正的服务提供者。 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。 客户端（client）以本地调用方式（即以接口的方式）调用服务； 客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）； 客户端通过socket将消息发送到服务端； 服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）； 服务端存根( server stub）根据解码结果调用本地的服务； 服务处理 本地服务执行并将结果返回给服务端存根( server stub）； 服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）； 服务端（server）通过socket将消息发送到客户端； 客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）； 客户端（client）得到最终结果。 RPC的目标是要把2、3、4、5、7、8、9、10这些步骤都封装起来。只剩下1、6、11 注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。 在java中RPC框架比较多，常见的有Hessian、gRPC、Dubbo 等，其实对 于RPC框架而言，核心模块就是通讯和序列化 ","link":"https://promonkeylee.github.io/post/rpc-kuang-jia/"},{"title":"事务传播行为","content":" 事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。 ","link":"https://promonkeylee.github.io/post/shi-wu-chuan-bo-xing-wei/"}]}