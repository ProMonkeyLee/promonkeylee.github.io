{"posts":[{"title":"架构设计基本原则","content":"1. 开闭原则 1.1 开闭原则的定义 开闭原则：软件实体应当对扩展开放，对修改关闭，这就是开闭原则的经典定义。 这里的软件实体包括以下几个部分： 项目中划分出的模块 类与接口 方法 **开闭原则的含义是：**当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 1.2 开闭原则的作用 开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。 对软件测试的影响 可以提高代码的可复用性 可以提高软件的可维护性 1.3 开闭原则的实现方法 可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 举例: 学校有许多的课程，其中有一门课程为java课程，我们需要打印出该课程的id、名称以及售价,为此新建一个接口类ICourse和实现类JavaCourse，JavaCourse实现接口ICours 此时，正好赶上节日，我们有一个促销活动，JAVA课程我们打六折 第一种选择: 在ICours新增打折方法getDiscountPrice, 这种会将所有实现ICours接口的实现类都得做改变 第二种选择： 每次打折我们都修改JavaCourse类,这种代码显然是不合理的，这样破坏了原本稳定的代码 第三种选择： 新建一个JavaDiscountCourse类继承JavaCourse，并在JavaDiscountCourse新增加一个打折 即可 2. 单一职责原则 2.1 单一职责原则的定义 单一职责原则又称单一功能原则，这里的职责是指类变化的原因，单一职责原则规定一个类应该有 且仅有一个引起它变化的原因，否则类应该被拆分。 该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 2.2 单一职责原则的优点 单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。 降低类的复杂度 提高类的可读性 提高系统的可维护性 变更引起的风险降低 2.3 单一职责原则的实现方法 单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。 大学学生工作管理程序: 3.接口隔离原则 3.1 接口隔离原则的定义 接口隔离原则要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 ** 3.2接口隔离原则的优点** 接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。 提高系统的灵活性和可维护性 降低系统的耦合性。 保证系统的稳定性 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余 3.3 接口隔离原则的实现方法 在具体应用接口隔离原则时，应该根据以下几个规则来衡量。 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 举例: 学生成绩管理程序学, 学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均 分、打印成绩信息、査询成绩信息等功能， 如果将这些功能全部放到一个接口中显然不太合理 正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中 4.里氏替换原则 4.1里氏替换原则的定义 里氏替换原则主要阐述了有关继承的一些原则。里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。总结:子类可以扩展父类的功能，但不能改变父类原有的功能 4.2 里氏替换原则的作用 里氏替换原则的主要作用如下。 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。 4.3里氏替换原则的实现方法 根据上述理解，对里氏替换原则的定义可以总结如下： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类中可以增加自己特有的方法 5.依赖倒置原则 5.1 依赖倒置原则定义 依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依 赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。 5.2依赖倒置原则的作用 依赖倒置原则的主要作用如下。 可以降低类间的耦合性。 可以提高系统的稳定性。 可以减少并行开发引起的风险。 可以提高代码的可读性和可维护性 5.3 依赖倒置原则的实现方法 依赖倒置原则在“顾客购物程序”中的应用 本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以 下代码定义了顾客类通过韶关网店 ShaoguanShop 购物： class Customer { public void shopping(ShaoguanShop shop) { //购物 System.out.println(shop.sell()); } } 但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下： class Customer { public void shopping(WuyuanShop shop) { //购物 System.out.println(shop.sell()); } } 顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是： 顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。 class Customer { public void shopping(Shop shop) { //购物 System.out.println(shop.sell()); } } 6.迪米特法则 6.1迪米特法则的定义 迪米特法则又叫作最少知识原则, 迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 6.2迪米特法则的优点 迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用性和系统的扩展性 6.3迪米特法则的实现方法 从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法。 案例:明星与经纪人的关系实例 分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则 //经纪人 class Agent { private Star myStar; private Fans myFans; private Company myCompany; public void setStar(Star myStar) { this.myStar = myStar; } public void setFans(Fans myFans) { this.myFans = myFans; } public void setCompany(Company myCompany) { this.myCompany = myCompany; } public void meeting() { System.out.println(myFans.getName() + &quot;与明星&quot; + myStar.getName() + &quot;见面了。&quot;); } public void business() { System.out.println(myCompany.getName() + &quot;与明星&quot; + myStar.getNam() + &quot;洽淡业务。&quot;); } } //明星 class Star { private String name; Star(String name) { this.name = name; } public String getName() { return name; } } //粉丝 class Fans { private String name; Fans(String name) { this.name = name; } public String getName() { return name; } } //媒体公司 class Company { private String name; Company(String name) { this.name = name; } public String getName() { return name; } } package principle; public class LoDtest { public static void main(String[] args) { Agent agent = new Agent(); agent.setStar(new Star(&quot;林心如&quot;)); agent.setFans(new Fans(&quot;粉丝韩丞&quot;)); agent.setCompany(new Company(&quot;中国传媒有限公司&quot;)); agent.meeting(); agent.business(); } } 7.合成复用原则 7.1合成复用原则的定义 合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则 （Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的， 两者都是开闭原则的具体实现规范。 7.2合成复用原则的重要性 通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性 子类与父类的耦合度高 它限制了复用的灵活性 采用合成复用原则时，他可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已 有对象的功能，它有以下优点。 它维持了类的封装性 新旧类之间的耦合度低 复用的灵活性高 7.3合成复用原则的实现方法 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已 有对象的功能，从而达到复用。 下面以汽车分类管理程序为例来介绍合成复用原则的应用。 分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。 所示是用继承关系实现的汽车分类的类图。 从上图 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题 ","link":"https://promonkeylee.github.io/post/jia-gou-she-ji-ji-ben-yuan-ze/"},{"title":"分布式理论","content":"什么是分布式系统 分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。 通俗的理解，所谓分布式系统，就是一个业务拆分成多个子业务，分布在不同的服务器节点，共同构成的系统称为分布式系统，同一个分布式系统中的服务器节点在空间部署上是可以随意分布的，这些服务器可能放在不同的机柜中，也可能在不同的机房中，甚至分布在不同的城市。 分布式与集群的区别 集群: 多个服务器做同一个事情 分布式: 多个服务器做不同的事情 分布式系统特性 分布性 空间中随机分布。这些计算机可以分布在不同的机房，不同的城市，甚至不同的国家。 对等性 分布式系统中的计算机没有主/从之分，组成分布式系统的所有节点都是对等的。 并发性 同一个分布式系统的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储。 缺乏全局时钟 既然各个计算机之间是依赖于交换信息来进行相互通信，很难定义两件事件的先后顺序，缺乏全局始终控制序列 故障总会发生 组成分布式的计算机，都有可能在某一时刻突然间崩掉。分的计算机越多，可能崩掉一个的几率就越大。如果再考虑到设计程序时的异常故障，也会加大故障的概率。 处理单点故障 单点SPoF（Single Point of Failure）：某个角色或者功能只有某一台计算机在支撑，在这台计算机上出现的故障是单点故障 分布式系统面临的问题 通信异常 网络分区 节点故障 三态(成功、失败和超时) 重发 幂等 数据一致性 强一致性 弱一致性 最终一致性 因果一致性 读己之所写一致性 会话一致性 单调读一致性 单调写一致性 一致性模型图 CAP定理 CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点 选项 具体意义 一致性（Consistency） 所有节点访问时都是同一份最新的数据副本 可用性（Availability） 每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据 分区容错性（Partitiontolerance） 分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障 ","link":"https://promonkeylee.github.io/post/fen-bu-shi-li-lun/"},{"title":"RPC框架","content":"分布式架构网络通信 在分布式服务框架中，一个最基础的问题就是远程服务是怎么通讯的，在Java领域中有很多可实现远程通讯的技术，例如：RMI、Hessian、SOAP、ESB和JMS等，它们背后到底是基于什么原理实现的呢？ 基本原理 要实现网络机器间的通讯，首先得来看看计算机系统网络通信的基本原理，在底层层面去看，网络通信需要做的就是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、aio三种方式，所有的分布式应用通讯都基于这个原理而实现 什么是RPC RPC全称为remote procedure call，即远程过程调用。借助RPC可以做到像本地调用一样调用远程服 务，是一种进程间的通信方式. 比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。 RPC架构 一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。 客户端(Client)，服务的调用方。 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。 服务端(Server)，真正的服务提供者。 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。 客户端（client）以本地调用方式（即以接口的方式）调用服务； 客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）； 客户端通过socket将消息发送到服务端； 服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）； 服务端存根( server stub）根据解码结果调用本地的服务； 服务处理 本地服务执行并将结果返回给服务端存根( server stub）； 服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）； 服务端（server）通过socket将消息发送到客户端； 客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）； 客户端（client）得到最终结果。 RPC的目标是要把2、3、4、5、7、8、9、10这些步骤都封装起来。只剩下1、6、11 注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。 在java中RPC框架比较多，常见的有Hessian、gRPC、Dubbo 等，其实对 于RPC框架而言，核心模块就是通讯和序列化 ","link":"https://promonkeylee.github.io/post/rpc-kuang-jia/"},{"title":"事务传播行为","content":" 事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。 ","link":"https://promonkeylee.github.io/post/shi-wu-chuan-bo-xing-wei/"}]}