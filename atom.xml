<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://promonkeylee.github.io</id>
    <title>糖果盒</title>
    <updated>2022-02-08T11:10:15.529Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://promonkeylee.github.io"/>
    <link rel="self" href="https://promonkeylee.github.io/atom.xml"/>
    <subtitle>读书点亮生活</subtitle>
    <logo>https://promonkeylee.github.io/images/avatar.png</logo>
    <icon>https://promonkeylee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 糖果盒</rights>
    <entry>
        <title type="html"><![CDATA[RPC框架]]></title>
        <id>https://promonkeylee.github.io/post/rpc-kuang-jia/</id>
        <link href="https://promonkeylee.github.io/post/rpc-kuang-jia/">
        </link>
        <updated>2022-02-08T10:53:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分布式架构网络通信"><strong>分布式架构网络通信</strong></h2>
<p>在分布式服务框架中，一个最基础的问题就是远程服务是怎么通讯的，在Java领域中有很多可实现远程通讯的技术，例如：RMI、Hessian、SOAP、ESB和JMS等，它们背后到底是基于什么原理实现的呢？</p>
<h3 id="基本原理"><strong>基本原理</strong></h3>
<p>要实现网络机器间的通讯，首先得来看看计算机系统网络通信的基本原理，在底层层面去看，网络通信需要做的就是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、aio三种方式，所有的分布式应用通讯都基于这个原理而实现</p>
<h3 id="什么是rpc"><strong>什么是RPC</strong></h3>
<p>RPC全称为remote procedure call，即远程过程调用。借助RPC可以做到像本地调用一样调用远程服<br>
务，是一种进程间的通信方式.</p>
<p>比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。<strong>需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644318052798.png" alt="" loading="lazy"></p>
<h3 id="rpc架构"><strong>RPC架构</strong></h3>
<p>一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。</p>
<blockquote>
<ul>
<li>客户端(Client)，服务的调用方。</li>
<li>客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li>
<li>服务端(Server)，真正的服务提供者。</li>
<li>服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li>
</ul>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://promonkeylee.github.io/post-images/1644318278407.png" alt="" loading="lazy"></figure>
<ol>
<li>客户端（client）以本地调用方式（即以接口的方式）调用服务；</li>
<li>客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；</li>
<li>客户端通过socket将消息发送到服务端；</li>
<li>服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）；</li>
<li>服务端存根( server stub）根据解码结果调用本地的服务；</li>
<li>服务处理</li>
<li>本地服务执行并将结果返回给服务端存根( server stub）；</li>
<li>服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；</li>
<li>服务端（server）通过socket将消息发送到客户端；</li>
<li>客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；</li>
<li>客户端（client）得到最终结果。</li>
</ol>
<p>RPC的目标是要把2、3、4、5、7、8、9、10这些步骤都封装起来。只剩下1、6、11</p>
<blockquote>
<p>注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。</p>
</blockquote>
<p>在java中RPC框架比较多，常见的有Hessian、gRPC、Dubbo 等，其实对 于RPC框架而言，核心模块就是<strong>通讯和序列化</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事务传播行为]]></title>
        <id>https://promonkeylee.github.io/post/shi-wu-chuan-bo-xing-wei/</id>
        <link href="https://promonkeylee.github.io/post/shi-wu-chuan-bo-xing-wei/">
        </link>
        <updated>2022-02-07T01:51:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
</blockquote>
<p><img src="https://promonkeylee.github.io/post-images/1644198765503.png" alt="" loading="lazy"><br>
<img src="https://promonkeylee.github.io/post-images/1644199052542.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>