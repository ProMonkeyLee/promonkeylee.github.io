<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://promonkeylee.github.io</id>
    <title>糖果盒</title>
    <updated>2023-01-28T05:41:03.543Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://promonkeylee.github.io"/>
    <link rel="self" href="https://promonkeylee.github.io/atom.xml"/>
    <subtitle>读书点亮生活</subtitle>
    <logo>https://promonkeylee.github.io/images/avatar.png</logo>
    <icon>https://promonkeylee.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, 糖果盒</rights>
    <entry>
        <title type="html"><![CDATA[K8S初始化集群及常用命令]]></title>
        <id>https://promonkeylee.github.io/post/k8s-chu-shi-hua-ji-qun-ji-chang-yong-ming-ling/</id>
        <link href="https://promonkeylee.github.io/post/k8s-chu-shi-hua-ji-qun-ji-chang-yong-ming-ling/">
        </link>
        <updated>2023-01-28T05:33:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="初始化集群">初始化集群</h2>
<h3 id="配置k8s集群网络">配置k8s集群网络</h3>
<h4 id="calico官网地址">calico官网地址</h4>
<pre><code># 官网下载地址：
https://docs.projectcalico.org/v3.14/manifests/calico.yaml

# github地址：
https://github.com/projectcalico/calico

# 镜像下载：
docker pull calico/cni:v3.14.2
docker pull calico/pod2daemon-flexvol:v3.14.2
docker pull calico/node:v3.14.2
docker pull calico/kube-controllers:v3.14.2

# 克隆其他节点注意事项：
# 1.配置hostname：
hostnamectl set-hostname k8s-master01
# 2.配置ip地址：
</code></pre>
<ol>
<li>初始化集群信息:calico网络</li>
</ol>
<pre><code>kubeadm init --apiserver-advertise-address=192.168.153.128 --kubernetes-version v1.17.5 --service-cidr=10.1.0.0/16 --pod-network-cidr=10.81.0.0/16
</code></pre>
<ol start="2">
<li>执行配置命令</li>
</ol>
<pre><code>mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<ol start="3">
<li>获取token及token证书</li>
</ol>
<pre><code>kubeadm token create --print-join-command
</code></pre>
<ol start="4">
<li>node节点加入集群信息</li>
</ol>
<pre><code>kubeadm join 192.168.153.128:6443 --token p7o1cx.mfo9umyq5fvz851r \
--discovery-token-ca-cert-hash sha256:fe704729bced7b872c9bdef554a0a4f7e17350780b5020afd94ab9d4ea327999
</code></pre>
<ol start="5">
<li>初始网络</li>
</ol>
<pre><code># 主节点
kubectl apply -f calico.yml
# 查看节点
kubectl get nodes
</code></pre>
<ol start="6">
<li>kubectl命令自动补全</li>
</ol>
<pre><code>echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bash_profile
source ~/.bash_profile
</code></pre>
<ol start="7">
<li>发送邮件问题（选择性）</li>
</ol>
<pre><code># 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。
echo &quot;unset MAILCHECK&quot;&gt;&gt; /etc/profile
source /etc/profile

# 在你的 bash shell 中永久的添加自动补全
</code></pre>
<ol start="8">
<li>yum-key.gpg验证未通过（选择性）</li>
</ol>
<pre><code>wget https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
wget https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
rpm --import yum-key.gpg
rpm --import rpm-package-key.gpg
</code></pre>
<ol start="9">
<li>删除节点</li>
</ol>
<pre><code># 如果需要在k8s集群中删除节点，首先需要在master节点上删除该节点的相关数据，再删除该节点，接着在该节点上进行reset操作，接着删除相关文件。
# 在Master节点操作
# 其中&lt; node name &gt;是在k8s集群中使用&lt; kubectl get nodes &gt;查询到的节点名称
kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets
kubectl delete node &lt;node name&gt;

# 在需要删除的节点上
sudo kubeadm reset

# 删除残留的文件
sudo rm -rf /etc/kubernetes/

# 清除iptables或者ipvs的配置
sudo iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X
sudo ipvsadm --clear

# 如果删除的是master节点，还需要删除用户目录下的.kube文件
rm -rf ~/.kube

# 最后重启设备。
</code></pre>
<ol start="10">
<li>添加节点</li>
</ol>
<pre><code># 生成token
# 查询token
kubeadm token list
# 创建一个token和证书
kubeadm token create --print-join-command
# 子节点加入
kubeadm join &lt;集群master节点IP：端口&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;sha256&gt; 
</code></pre>
<h2 id="k8s常用命令">K8s常用命令</h2>
<ol>
<li>强制删除Pod</li>
</ol>
<pre><code># 强制删除POD
kubectl delete pod [pod name] --force --grace-period=0 -n [namespace]
</code></pre>
<ol start="2">
<li>get命令</li>
</ol>
<pre><code># 查看集群状态信息
kubectl cluster-info
# 查看集群状态
kubectl get cs
# 查看集群节点信息
kubectl get nodes
# 查看集群命名空间
kubectl get ns
# 查看指定命名空间的服务
kubectl get svc -n kube-system
# 以纯文本输出格式列出所有 pod。
kubectl get pods
# 以纯文本输出格式列出所有 pod，并包含附加信息(如节点名)。
kubectl get pods -o wide
# 以纯文本输出格式列出具有指定名称的副本控制器。提示：您可以使用别名 'rc' 缩短和替换'replicationcontroller' 资源类型。
kubectl get replicationcontroller &lt;rc-name&gt;
# 以纯文本输出格式列出所有副本控制器和服务。
kubectl get rc,services
# 以纯文本输出格式列出所有守护程序集，包括未初始化的守护程序集。
kubectl get ds --include-uninitialized
# 列出在节点 server01 上运行的所有 pod
kubectl get pods --field-selector=spec.nodeName=server01
</code></pre>
<ol start="3">
<li>describe命令</li>
</ol>
<pre><code># 显示名称为 &lt;node-name&gt; 的节点的详细信息。
kubectl describe nodes &lt;node-name&gt;
# 显示名为 &lt;pod-name&gt; 的 pod 的详细信息。
kubectl describe pods/&lt;pod-name&gt;
# 显示由名为 &lt;rc-name&gt; 的副本控制器管理的所有 pod 的详细信息。
# 记住：副本控制器创建的任何 pod 都以复制控制器的名称为前缀。
kubectl describe pods &lt;rc-name&gt;
# 描述所有的 pod，不包括未初始化的 pod
kubectl describe pods --include-uninitialized=false
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Cloud 核心组件]]></title>
        <id>https://promonkeylee.github.io/post/spring-cloud-he-xin-zu-jian/</id>
        <link href="https://promonkeylee.github.io/post/spring-cloud-he-xin-zu-jian/">
        </link>
        <updated>2022-03-10T13:19:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="eureka服务注册中心">Eureka服务注册中心</h2>
<ul>
<li>Eureka 包含两个组件： <strong>Eureka Server 和 Eureka Client</strong>， Eureka Client是⼀个Java客户端，⽤于简化与Eureka Server的交互； Eureka Server提供服务发现的能⼒，各个微服务启动时，会通过Eureka Client向Eureka Server 进⾏注册⾃⼰的信息（例如⽹络信息）， Eureka Server会存储该服务的信息；</li>
<li>Eureka通过⼼跳检测、健康检查和客户端缓存等机制，提⾼系统的灵活性、可伸缩性和可⽤性。</li>
</ul>
<h4 id="eureka应用及高可用集群">Eureka应⽤及⾼可⽤集群</h4>
<ol>
<li>单实例Eureka Server—&gt;访问管理界⾯—&gt;Eureka Server集群</li>
<li>服务提供者（简历微服务注册到集群）</li>
<li>服务消费者（⾃动投递微服务注册到集群/从Eureka Server集群获取服务信息）</li>
<li>完成调⽤</li>
</ol>
<h4 id="搭建单例eureka-server服务注册中心">搭建单例Eureka Server服务注册中⼼</h4>
<ul>
<li>引入依赖</li>
</ul>
<pre><code>&lt;dependencies&gt;
    &lt;!--Eureka server依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eurekaserver&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<ul>
<li>application.yml</li>
</ul>
<pre><code>#Eureka server服务端⼝
server:
    port: 8761
spring:
    application:
        name: lagou-cloud-eureka-server # 应⽤名称，会在Eureka中作为服务的id标识（serviceId）
eureka:
    instance:
        hostname: localhost
    client:
        service-url: # 客户端与EurekaServer交互的地址，如果是集群，也需要写其它Server的地址
            defaultZone:
http://${eureka.instance.hostname}:${server.port}/eureka/
        register-with-eureka: false # ⾃⼰就是服务不需要注册⾃⼰
        fetch-registry: false #⾃⼰就是服务不需要从Eureka Server获取服务信息,默认为true，置为false
</code></pre>
<ul>
<li>SpringBoot启动类，使⽤@EnableEurekaServer声明当前项⽬为EurekaServer服务</li>
</ul>
<pre><code>package com.lagou.edu;
import org.springframework.boot.SpringApplication;
importorg.springframework.boot.autoconfigure.SpringBootApplication;
importorg.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
@SpringBootApplication
// 声明本项⽬是⼀个Eureka服务
@EnableEurekaServer
public class LagouCloudEurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(LagouCloudEurekaServerApplication.class,args);
    }
}
</code></pre>
<h2 id="ribbon负载均衡">Ribbon负载均衡</h2>
<p>负载均衡⼀般分为服务器端负载均衡和客户端负载均衡</p>
<ul>
<li>所谓服务器端负载均衡，⽐如Nginx、 F5这些，请求到达服务器之后由这些负载均衡器根据⼀定的算法将请求路由到⽬标服务器处理。</li>
<li>所谓客户端负载均衡，⽐如我们要说的Ribbon，服务消费者客户端会有⼀个服务器地址列表，调⽤⽅在请求前通过⼀定的负载均衡算法选择⼀个服务器进⾏访问，负载均衡算法的执⾏是在请求客户端进⾏。</li>
</ul>
<p>Ribbon是Netflix发布的负载均衡器。 Eureka⼀般配合Ribbon进⾏使⽤， Ribbon利⽤从Eureka中读取到服务信息，在调⽤服务提供者提供的服务时，会根据⼀定的算法进⾏负载。</p>
<h4 id="ribbon负载均衡策略">Ribbon负载均衡策略</h4>
<p>Ribbon内置了多种负载均衡策略，内部负责复杂均衡的顶级接⼝为<br>
com.netflix.loadbalancer.IRule</p>
<table>
<thead>
<tr>
<th><strong>负载均衡策略</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>RoundRobinRule：轮询策略</td>
<td>默认超过10次获取到的server都不可⽤，会返回⼀个空的server</td>
</tr>
<tr>
<td>RandomRule：随机策略</td>
<td>如果随机到的server为null或者不可⽤的话，会while不停的循环选取</td>
</tr>
<tr>
<td>RetryRule：重试策略</td>
<td>⼀定时限内循环重试。默认继承RoundRobinRule，也⽀持⾃定义注⼊，RetryRule会在每次选取之后，对选举的server进⾏判断，是否为null，是否alive，并且在500ms内会不停的选取判断。⽽RoundRobinRule失效的策略是超过10次， RandomRule是没有失效时间的概念，只要serverList没都挂。</td>
</tr>
<tr>
<td>BestAvailableRule：最⼩连接数策略</td>
<td>遍历serverList，选取出可⽤的且连接数最⼩的⼀个server。该算法⾥⾯有⼀个LoadBalancerStats的成员变量，会存储所有server的运⾏状况和连接数。如果选取到的server为null，那么会调⽤RoundRobinRule重新选取。 1（1） 2（1）3（1）</td>
</tr>
<tr>
<td>AvailabilityFilteringRule：可⽤过滤策略</td>
<td>扩展了轮询策略，会先通过默认的轮询选取⼀个server，再去判断该server是否超时可⽤，当前连接数是否超限，都成功再返回。</td>
</tr>
<tr>
<td>ZoneAvoidanceRule：区域权衡策略（默认策略）</td>
<td>扩展了轮询策略，继承了2个过滤器：ZoneAvoidancePredicate和AvailabilityPredicate，除了过滤超时和链接数过多的server，还会过滤掉不符合要求的zone区域⾥⾯的所有节点， AWS --ZONE 在⼀个区域/机房内的服务实例中轮询</td>
</tr>
</tbody>
</table>
<p>修改负载均衡策略</p>
<pre><code>#针对的被调⽤⽅微服务名称,不加就是全局⽣效
lagou-service-resume:
    ribbon:
        NFLoadBalancerRuleClassName:
com.netflix.loadbalancer.RandomRule #负载策略调整
</code></pre>
<h2 id="hystrix熔断器">Hystrix熔断器</h2>
<p><strong>属于⼀种容错机制</strong><br>
什么是微服务中的雪崩效应呢？<br>
在微服务架构中，⼀个应⽤可能会有多个微服务组成，微服务之间的数据交互通过<br>
远程过程调⽤完成。这就带来⼀个问题，假设微服务A调⽤微服务B和微服务C，微<br>
服务B和微服务C⼜调⽤其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某<br>
个微服务的调⽤响应时间过⻓或者不可⽤，对微服务A的调⽤就会占⽤越来越多的系<br>
统资源，进⽽引起系统崩溃，所谓的“雪崩效应”。<br>
<strong>雪崩效应解决⽅案</strong></p>
<ul>
<li>服务熔断</li>
<li>服务降级</li>
<li>服务限流</li>
</ul>
<h2 id="feign远程调用组件">Feign远程调⽤组件</h2>
<p>Feign是Netflix开发的⼀个轻量级<strong>RESTful的HTTP服务客户端</strong>（⽤它来发起请求，<br>
远程调⽤的） ，是以Java接⼝注解的⽅式调⽤Http请求，⽽不⽤像Java中通过封装<br>
HTTP请求报⽂的⽅式直接调⽤， Feign被⼴泛应⽤在Spring Cloud 的解决⽅案中。<br>
<strong>本质：封装了Http调⽤流程，更符合⾯向接⼝化的编程习惯，类似于Dubbo的服务调⽤</strong><br>
<strong>Feign = RestTemplate+Ribbon+Hystrix</strong></p>
<h2 id="gateway网关组件">GateWay⽹关组件</h2>
<p>基于<strong>Spring5.0+SpringBoot2.0+WebFlux</strong>（基于⾼性能的Reactor模式响应式通信<br>
框架Netty，异步⾮阻塞模型）等技术开发，性能⾼于Zuul，官⽅测试， GateWay是<br>
Zuul的1.6倍，旨在为微服务架构提供⼀种简单有效的统⼀的API路由管理⽅式。</p>
<p>Spring Cloud GateWay不仅提供统⼀的路由⽅式（反向代理）并且基于 Filter(定义过滤器对请求过滤，完成⼀些功能) 链的⽅式提供了⽹关基本的功能，例如：<strong>鉴权、流量控制、熔断、路径重写、⽇志监控</strong>等。</p>
<h4 id="gateway核心概念">GateWay核⼼概念</h4>
<ul>
<li>路由（route）： ⽹关最基础的部分，也是⽹关⽐较基础的⼯作单元。路由由⼀个ID、⼀个⽬标URL（最终路由到的地址）、⼀系列的断⾔（匹配条件判断）和Filter过滤器（精细化控制）组成。如果断⾔为true，则匹配该路由。</li>
<li>断⾔（predicates）：参考了Java8中的断⾔java.util.function.Predicate，开发⼈员可以匹配Http请求中的所有内容（包括请求头、请求参数等）（类似于nginx中的location匹配⼀样），如果断⾔与请求相匹配则路由。</li>
<li>过滤器（filter）：⼀个标准的Spring webFilter，使⽤过滤器，可以在请求之前或者之后执⾏业务逻辑。</li>
</ul>
<h2 id="spring-cloud-config-分布式配置中心">Spring Cloud Config 分布式配置中⼼</h2>
<p>Spring Cloud Config是⼀个分布式配置管理⽅案，包含了 Server端和 Client端两个部分。<br>
<strong>作⽤：对配置⽂件进⾏集中式管理</strong></p>
<ul>
<li>Server 端：提供配置⽂件的存储、以接⼝的形式将配置⽂件的内容提供出去，通过使⽤@EnableConfigServer注解在 Spring boot 应⽤中⾮常简单的嵌⼊</li>
<li>Client 端：通过接⼝获取配置数据并初始化⾃⼰的应⽤</li>
</ul>
<h2 id="spring-cloud-stream消息驱动组件">Spring Cloud Stream消息驱动组件</h2>
<p><strong>本质： 屏蔽掉了底层不同MQ消息中间件之间的差异，统⼀了MQ的编程模型，降低了学习、开发、维护MQ的成本</strong><br>
<img src="https://promonkeylee.github.io/post-images/1646920794975.png" alt="" loading="lazy"></p>
<p><strong>Stream编程注解</strong></p>
<table>
<thead>
<tr>
<th><strong>注解</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>@Input（在消费者⼯程中使⽤）</td>
<td>注解标识输⼊通道，通过该输⼊通道接收到的消息进⼊应⽤程序</td>
</tr>
<tr>
<td>@Output（在⽣产者⼯程中使⽤）</td>
<td>注解标识输出通道，发布的消息将通过该通道离开应⽤程序</td>
</tr>
<tr>
<td>@StreamListener（在消费者⼯程中使⽤，监听message的到来）</td>
<td>监听队列，⽤于消费者的队列消息的接收（有消息监听.....）</td>
</tr>
<tr>
<td>@EnableBinding</td>
<td>把Channel和Exchange（对于RabbitMQ）绑定在⼀起</td>
</tr>
</tbody>
</table>
<h2 id="微服务监控之分布式链路追踪技术-sleuth-zipkin">微服务监控之分布式链路追踪技术 Sleuth +Zipkin</h2>
<p>本质：记录⽇志，作为⼀个完整的技术，分布式链路追踪也有⾃⼰的理论和概念微服务架构中，针对请求处理的调⽤链可以展现为⼀棵树，示意如下:<br>
<img src="https://promonkeylee.github.io/post-images/1646921034339.png" alt="" loading="lazy"><br>
<strong>Trace：</strong> 服务追踪的追踪单元是从客户发起请求（request）抵达被追踪系统的边界开始，到被追踪系统向客户返回响应（response）为⽌的过程</p>
<p><strong>Trace ID：</strong> 为了实现请求跟踪，当请求发送到分布式系统的⼊⼝端点时，只需要服务跟踪框架为该请求创建⼀个唯⼀的跟踪标识Trace ID，同时在分布式系统内部流转的时候，框架失踪保持该唯⼀标识，直到返回给请求⽅</p>
<p>⼀个Trace由⼀个或者多个Span组成，每⼀个Span都有⼀个SpanId， Span中会记录<br>
TraceId，同时还有⼀个叫做ParentId，指向了另外⼀个Span的SpanId，表明⽗⼦<br>
关系，其实本质表达了依赖关系</p>
<p><strong>Span ID：</strong> 为了统计各处理单元的时间延迟，当请求到达各个服务组件时，也是通过<br>
⼀个唯⼀标识Span ID来标记它的开始，具体过程以及结束。对每⼀个Span来说，<br>
它必须有开始和结束两个节点，通过记录开始Span和结束Span的时间戳，就能统计<br>
出该Span的时间延迟，除了时间戳记录之外，它还可以包含⼀些其他元数据，⽐如<br>
时间名称、请求信息等。</p>
<p>每⼀个Span都会有⼀个唯⼀跟踪标识 Span ID,若⼲个有序的 span 就组成了⼀个trace。</p>
<p>Span可以认为是⼀个⽇志数据结构，在⼀些特殊的时机点会记录了⼀些⽇志信息，<br>
⽐如有时间戳、 spanId、 TraceId， parentIde等， Span中也抽象出了另外⼀个概<br>
念，叫做事件，核⼼事件如下:</p>
<ul>
<li>CS ： client send/start 客户端/消费者发出⼀个请求，描述的是⼀个span开始</li>
<li>SR: server received/start 服务端/⽣产者接收请求 SR-CS属于请求发送的⽹络延迟</li>
<li>SS: server send/finish 服务端/⽣产者发送应答 SS-SR属于服务端消耗时间</li>
<li>CR： client received/finished 客户端/消费者接收应答 CR-SS表示回复需要的时间(响应的⽹络延迟)</li>
</ul>
<p>Spring Cloud Sleuth （追踪服务框架）可以追踪服务之间的调⽤， Sleuth可以记录<br>
⼀个服务请求经过哪些服务、服务处理时⻓等，根据这些，我们能够理清各微服务<br>
间的调⽤关系及进⾏问题追踪分析。</p>
<ul>
<li>耗时分析：通过 Sleuth 了解采样请求的耗时，分析服务性能问题（哪些服务调⽤⽐较耗时）</li>
<li>链路优化：发现频繁调⽤的服务，针对性优化等Sleuth就是通过记录⽇志的⽅式来记录踪迹数据的</li>
</ul>
<p><strong>注意：我们往往把Spring Cloud Sleuth 和 Zipkin ⼀起使⽤，把 Sleuth 的数据信息发送给 Zipkin 进⾏聚合，利⽤ Zipkin 存储并展示数据。</strong></p>
<h2 id="微服务统一认证方案-spring-cloud-oauth2-jwt"><strong>微服务统⼀认证⽅案 Spring Cloud OAuth2 +JWT</strong></h2>
<p>OAuth（开放授权）是⼀个开放协议/标准，允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容。</p>
<p><strong>允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容</strong><br>
<img src="https://promonkeylee.github.io/post-images/1646921259428.png" alt="" loading="lazy"></p>
<ul>
<li>资源所有者（Resource Owner）：可以理解为⽤户⾃⼰</li>
<li>客户端（Client）：我们想登陆的⽹站或应⽤，⽐如拉勾⽹</li>
<li>认证服务器（Authorization Server）：可以理解为微信或者QQ</li>
<li>资源服务器（Resource Server）：可以理解为微信或者QQ</li>
</ul>
<h4 id="oauth2的颁发token授权方式">OAuth2的颁发Token授权⽅式</h4>
<ol>
<li>授权码（authorization-code）</li>
<li>密码式（password）提供⽤户名+密码换取token令牌</li>
<li>隐藏式（implicit）</li>
<li>客户端凭证（client credentials）</li>
</ol>
<h4 id="spring-cloud-oauth2介绍">Spring Cloud OAuth2介绍</h4>
<p>Spring Cloud OAuth2 是 Spring Cloud 体系对OAuth2协议的实现，可以⽤来做多<br>
个微服务的统⼀认证（验证身份合法性）授权（验证权限）。通过向OAuth2服务<br>
（统⼀认证授权服务）发送某个类型的grant_type进⾏集中认证和授权，从⽽获得<br>
access_token（访问令牌），⽽这个token是受其他微服务信任的。<br>
<strong>注意：使⽤OAuth2解决问题的本质是，引⼊了⼀个认证授权层，认证授权层连接了资源的拥有者，在授权层⾥⾯，资源的拥有者可以给第三⽅应⽤授权去访问我们的某些受保护资源。</strong></p>
<h4 id="spring-cloud-oauth2构建微服务统一认证服务思路">Spring Cloud OAuth2构建微服务统⼀认证服务思路</h4>
<p><img src="https://promonkeylee.github.io/post-images/1646921411285.png" alt="" loading="lazy"><br>
<strong>注意：在我们统⼀认证的场景中， Resource Server其实就是我们的各种受保护的微服务，微服务中的各种API访问接⼝就是资源，发起http请求的浏览器就是Client客户端（对应为第三⽅应⽤）</strong></p>
<h2 id="jwt改造统一认证授权中心的令牌存储机制"><strong>JWT改造统⼀认证授权中⼼的令牌存储机制</strong></h2>
<p><strong>JWT令牌介绍</strong><br>
JSON Web Token（JWT）是⼀个开放的⾏业标准（RFC 7519），它定义了⼀种简介<br>
的、⾃包含的协议格式，⽤于 在通信双⽅传递json对象，传递的信息经过数字签名<br>
可以被验证和信任。 JWT可以使⽤HMAC算法或使⽤RSA的公 钥/私钥对来签名，防<br>
⽌被篡改。<br>
<strong>JWT令牌结构</strong><br>
JWT令牌由三部分组成，每部分中间使⽤点（.）分隔，⽐如： xxxxx.yyyyy.zzzzz</p>
<ul>
<li>Header
<ul>
<li>头部包括令牌的类型（即JWT）及使⽤的哈希算法（如HMAC SHA256或RSA）</li>
</ul>
</li>
<li>Payload
<ul>
<li>第⼆部分是负载，内容也是⼀个json对象，它是存放有效信息的地⽅，它可以存放jwt提供的现成字段，⽐ 如： iss（签发者） ,exp（过期时间戳） , sub（⾯向的⽤户）等，也可⾃定义字段。 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。 最后将第⼆部分负载使⽤Base64Url编码，得到⼀个字符串就是JWT令牌的第⼆部分。</li>
</ul>
</li>
<li>Signature
<ul>
<li>第三部分是签名，此部分⽤于防⽌jwt内容被篡改。 这个部分使⽤base64url将前两部分进⾏编码，编码后使⽤点（.）连接组成字符串，最后使⽤header中声明 签名算法进⾏签名。</li>
</ul>
</li>
</ul>
<p><strong>关于JWT令牌我们需要注意</strong></p>
<ul>
<li>JWT令牌就是⼀种可以被验证的数据组织格式，它的玩法很灵活，我们这⾥是基于Spring Cloud Oauth2 创建、校验JWT令牌</li>
<li>我们也可以⾃⼰写⼯具类⽣成、校验JWT令牌</li>
<li>JWT令牌中不要存放过于敏感的信息，因为我们知道拿到令牌后，我们可以解码看到载荷部分的信息</li>
<li>JWT令牌每次请求都会携带，内容过多，会增加⽹络带宽占⽤</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot 热插拔技术]]></title>
        <id>https://promonkeylee.github.io/post/springboot-re-cha-ba-ji-zhu/</id>
        <link href="https://promonkeylee.github.io/post/springboot-re-cha-ba-ji-zhu/">
        </link>
        <updated>2022-02-18T01:10:06.000Z</updated>
        <content type="html"><![CDATA[<p>还记得我们经常会在启动类Application上面加@EnableXXX注解吗？<br>
其实这个@Enablexxx注解就是一种热拔插技术，加了这个注解就可以启动对应的starter，当不需要对应的starter的时候只需要把这个注解注释掉就行，是不是很优雅呢？那么这是如何实现的呢？</p>
<ol>
<li>新增标记类ConfigMarker<pre><code>public class ConfigMarker {

}
</code></pre>
</li>
<li>新增EnableRegisterServer注解<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Import({ConfigMarker.class})
public @interface EnableRegisterServer {

}
</code></pre>
</li>
<li>改造 MyAutoConfiguration 新增条件注解 @ConditionalOnBean(ConfigMarker.class) ，@ConditionalOnBean 这个是条件注解，前面的意思代表只有当期上下文中含有 ConfigMarker对象，被标注的类才会被实例化。<pre><code>@Configuration
@ConditionalOnBean(ConfigMarker.class)
public class MyAutoConfiguration {
    static {
        System.out.println(&quot;MyAutoConfiguration init....&quot;);
    } 
    @Bean
    public SimpleBean simpleBean(){ 
        return new SimpleBean();
    }
}
</code></pre>
</li>
<li>改造service工程<br>
在启动类上新增@EnableImRegisterServer注解<br>
<img src="https://promonkeylee.github.io/post-images/1645146995575.png" alt="" loading="lazy"><br>
到此热插拔就实现好了，当你加了 @EnableImRegisterServer 的时候启动zdy工程就会自动装配<br>
SimpleBean，反之则不装配。<br>
原理也很简单，当加了 @EnableImRegisterServer 注解的时候，由于这个注解使用了<br>
@Import({ConfigMarker.class}) ，所以会导致Spring去加载 ConfigMarker 到上下文中，而又因为条件注解 @ConditionalOnBean(ConfigMarker.class) 的存在，所以MyAutoConfiguration 类就会被实例化。</li>
</ol>
<h3 id="关于条件注解的讲解"><strong>关于条件注解的讲解</strong></h3>
<ul>
<li>@ConditionalOnBean：仅仅在当前上下文中存在某个对象时，才会实例化一个Bean。</li>
<li>@ConditionalOnClass：某个class位于类路径上，才会实例化一个Bean。</li>
<li>@ConditionalOnExpression：当表达式为true的时候，才会实例化一个Bean。基于SpEL表达式的条件判断。</li>
<li>@ConditionalOnMissingBean：仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean。</li>
<li>@ConditionalOnMissingClass：某个class类路径上不存在的时候，才会实例化一个Bean。</li>
<li>@ConditionalOnNotWebApplication：不是web应用，才会实例化一个Bean。</li>
<li>@ConditionalOnWebApplication：当项目是一个Web项目时进行实例化。</li>
<li>@ConditionalOnNotWebApplication：当项目不是一个Web项目时进行实例化。</li>
<li>@ConditionalOnProperty：当指定的属性有指定的值时进行实例化。</li>
<li>@ConditionalOnJava：当JVM版本为指定的版本范围时触发实例化。</li>
<li>@ConditionalOnResource：当类路径下有指定的资源时触发实例化。</li>
<li>@ConditionalOnJndi：在JNDI存在的条件下触发实例化。</li>
<li>@ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dubbo配置项说明]]></title>
        <id>https://promonkeylee.github.io/post/dubbo-pei-zhi-xiang-shuo-ming/</id>
        <link href="https://promonkeylee.github.io/post/dubbo-pei-zhi-xiang-shuo-ming/">
        </link>
        <updated>2022-02-15T06:54:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1dubboapplication">1.dubbo:application</h2>
<p>对应 org.apache.dubbo.config.ApplicationConfig, 代表当前应用的信息</p>
<ol>
<li>name: 当前应用程序的名称，在dubbo-admin中我们也可以看到，这个代表这个应用名称。我们在真正时是时也会根据这个参数来进行聚合应用请求。</li>
<li>owner: 当前应用程序的负责人，可以通过这个负责人找到其相关的应用列表，用于快速定位到责任人。</li>
<li>qosEnable : 是否启动QoS 默认true</li>
<li>qosPort : 启动QoS绑定的端口 默认22222</li>
<li>qosAcceptForeignIp: 是否允许远程访问 默认是false</li>
</ol>
<h2 id="2dubboregistry">2.dubbo:registry</h2>
<p>org.apache.dubbo.config.RegistryConfig, 代表该模块所使用的注册中心。一个模块中的服务可以将其注册到多个注册中心上，也可以注册到一个上。后面再service和reference也会引入这个注册中心。</p>
<ol>
<li>id : 当当前服务中provider或者consumer中存在多个注册中心时，则使用需要增加该配置。在一些公司，会通过业务线的不同选择不同的注册中心，所以一般都会配置该值。</li>
<li>address : 当前注册中心的访问地址。</li>
<li>protocol : 当前注册中心所使用的协议是什么。也可以直接在 address 中写入，比如使用zookeeper，就可以写成 zookeeper://xx.xx.xx.xx:2181</li>
<li>timeout : 当与注册中心不再同一个机房时，大多会把该参数延长。</li>
</ol>
<h2 id="3dubboprotocol">3.dubbo:protocol</h2>
<p>org.apache.dubbo.config.ProtocolConfig, 指定服务在进行数据传输所使用的协议。</p>
<ol>
<li>id : 在大公司，可能因为各个部门技术栈不同，所以可能会选择使用不同的协议进行交互。这里在多个协议使用时，需要指定。</li>
<li>name : 指定协议名称。默认使用 dubbo 。</li>
</ol>
<h2 id="4-dubboservice">4. dubbo:service</h2>
<p>org.apache.dubbo.config.ServiceConfig, 用于指定当前需要对外暴露的服务信息，后面也会具体讲解。和 dubbo:reference 大致相同。</p>
<ol>
<li>interface : 指定当前需要进行对外暴露的接口是什么。</li>
<li>ref : 具体实现对象的引用，一般我们在生产级别都是使用Spring去进行Bean托管的，所以这里面一般也指的是Spring中的BeanId。</li>
<li>version : 对外暴露的版本号。不同的版本号，消费者在消费的时候只会根据固定的版本号进行消费。</li>
</ol>
<h2 id="5dubboreference">5.dubbo:reference</h2>
<p>org.apache.dubbo.config.ReferenceConfig, 消费者的配置，这里只做简单说明，后面会具体讲解。</p>
<ol>
<li>id : 指定该Bean在注册到Spring中的id。</li>
<li>interface: 服务接口名</li>
<li>version : 指定当前服务版本，与服务提供者的版本一致。</li>
<li>registry : 指定所具体使用的注册中心地址。这里面也就是使用上面在 dubbo:registry 中所声明的id。</li>
</ol>
<h2 id="6dubbomethod">6.dubbo:method</h2>
<p>org.apache.dubbo.config.MethodConfig, 用于在制定的 dubbo:service 或者dubbo:reference 中的更具体一个层级，指定具体方法级别在进行RPC操作时候的配置，可以理解为对这上面层级中的配置针对于具体方法的特殊处理。</p>
<ol>
<li>name : 指定方法名称，用于对这个方法名称的RPC调用进行特殊配置。</li>
<li>async: 是否异步 默认false</li>
</ol>
<h2 id="7dubboservice和dubboreference详解">7.dubbo:service和dubbo:reference详解</h2>
<p>这两个在dubbo中是我们最为常用的部分，其中有一些我们必然会接触到的属性。并且这里会讲到一些设置上的使用方案。</p>
<ol>
<li>mock: 用于在方法调用出现错误时，当做服务降级来统一对外返回结果，后面我们也会对这个方法做更多的介绍。</li>
<li>timeout: 用于指定当前方法或者接口中所有方法的超时时间。我们一般都会根据提供者的时长来具体规定。比如我们在进行第三方服务依赖时可能会对接口的时长做放宽，防止第三方服务不稳定导致服务受损。</li>
<li>check: 用于在启动时，检查生产者是否有该服务。我们一般都会将这个值设置为false，不让其进行检查。因为如果出现模块之间循环引用的话，那么则可能会出现相互依赖，都进行check的话，那么这两个服务永远也启动不起来。</li>
<li>retries: 用于指定当前服务在执行时出现错误或者超时时的重试机制。
<ol>
<li>注意提供者是否有幂等，否则可能出现数据一致性问题</li>
<li>注意提供者是否有类似缓存机制，如出现大面积错误时，可能因为不停重试导致雪崩</li>
</ol>
</li>
<li>executes: 用于在提供者做配置，来确保最大的并行度。
<ol>
<li>可能导致集群功能无法充分利用或者堵塞</li>
<li>但是也可以启动部分对应用的保护功能</li>
<li>可以不做配置，结合后面的熔断限流使用</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zookeeper服务启动]]></title>
        <id>https://promonkeylee.github.io/post/zookeeper-fu-wu-qi-dong/</id>
        <link href="https://promonkeylee.github.io/post/zookeeper-fu-wu-qi-dong/">
        </link>
        <updated>2022-02-12T02:25:17.000Z</updated>
        <content type="html"><![CDATA[<p>Zookeeper服务器的启动，⼤致可以分为以下五个步骤</p>
<blockquote>
<ol>
<li>配置⽂件解析</li>
<li>初始化数据管理器</li>
<li>初始化⽹络I/O管理器</li>
<li>数据恢复</li>
<li>对外服务</li>
</ol>
</blockquote>
<p><strong>单机版服务器启动</strong><br>
<strong>1. 预启动</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644633655133.png" alt="" loading="lazy"><br>
<img src="https://promonkeylee.github.io/post-images/1644632919808.png" alt="" loading="lazy"><br>
<strong>2. 初始化</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644633708482.png" alt="" loading="lazy"><br>
<strong>集群服务器启动</strong><br>
<strong>1. 预启动</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644633744286.png" alt="" loading="lazy"><br>
<strong>2. 初始化</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644633761934.png" alt="" loading="lazy"><br>
<strong>3. Leader选举</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644633772036.png" alt="" loading="lazy"><br>
<strong>4. Leader和Follower启动期交互过程</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644634155415.png" alt="" loading="lazy"><br>
1. 创建Leader服务器和Follower服务器。完成Leader选举后，每个服务器会根据自己服务器的角色创建相应的服务器实例，并进入各自角色的主流程。<br>
2. Leader服务器启动Follower接收器LearnerCnxAcceptor。运行期间， Leader服务器需要和所有其余的服务器（统称为Learner）保持连接以确集群的机器存活情况， LearnerCnxAcceptor负责接收所有非Leader服务器的连接请求。<br>
3. Learner服务器开始和Leader建立连接。所有Learner会找到Leader服务器，并与其建立连接。<br>
4. Leader服务器创建LearnerHandler。 Leader接收到来自其他机器连接创建请求后，会创建一个LearnerHandler实例，每个LearnerHandler实例都对应一个Leader与Learner服务器之间的连接，其负责Leader和Learner服务器之间几乎所有的消息通信和数据同步。<br>
5. 向Leader注册。 Learner完成和Leader的连接后，会向Leader进行注册，即将Learner服务器的基本信息（LearnerInfo），包括SID和ZXID，发送给Leader服务器。<br>
6. Leader解析Learner信息，计算新的epoch。 Leader接收到Learner服务器基本信息后，会解析出该Learner的SID和ZXID，然后根据ZXID解析出对应的epoch_of_learner，并和当前Leader服务器的epoch_of_leader进行比较，如果该Learner的epoch_of_learner更大，则更新Leader的epoch_of_leader = epoch_of_learner + 1。然后LearnHandler进行等待，直到过半Learner已经向Leader进行了注册，同时更新了epoch_of_leader后， Leader就可以确定当前集群的epoch了。<br>
7. 发送Leader状态。计算出新的epoch后， Leader会将该信息以一个LEADERINFO消息的形式发送给Learner，并等待Learner的响应。<br>
8. Learner发送ACK消息。 Learner接收到LEADERINFO后，会解析出epoch和ZXID，然后向Leader反馈一个ACKEPOCH响应。<br>
9. 数据同步。 Leader收到Learner的ACKEPOCH后，即可进行数据同步。<br>
10. 启动Leader和Learner服务器。当有过半Learner已经完成了数据同步，那么Leader和Learner服务器实例就可以启动了。</p>
<p><strong>5. Leader和Follower启动</strong><br>
1. 创建启动会话管理器。<br>
2. 初始化Zookeeper请求处理链，集群模式的每个处理器也会在启动阶段串联请求处理链。<br>
3. 注册JMX服务。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[架构设计基本原则]]></title>
        <id>https://promonkeylee.github.io/post/jia-gou-she-ji-ji-ben-yuan-ze/</id>
        <link href="https://promonkeylee.github.io/post/jia-gou-she-ji-ji-ben-yuan-ze/">
        </link>
        <updated>2022-02-10T02:44:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-开闭原则">1. 开闭原则</h2>
<h3 id="11-开闭原则的定义">1.1 开闭原则的定义</h3>
<p>开闭原则：软件实体应当对扩展开放，对修改关闭，这就是开闭原则的经典定义。</p>
<p>这里的软件实体包括以下几个部分：</p>
<ol>
<li>项目中划分出的模块</li>
<li>类与接口</li>
<li>方法</li>
</ol>
<p>**开闭原则的含义是：**当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>
<h3 id="12-开闭原则的作用">1.2 开闭原则的作用</h3>
<p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。</p>
<ol>
<li>对软件测试的影响</li>
<li>可以提高代码的可复用性</li>
<li>可以提高软件的可维护性</li>
</ol>
<h3 id="13-开闭原则的实现方法">1.3 开闭原则的实现方法</h3>
<p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。<br>
<strong>举例:</strong></p>
<ol>
<li>学校有许多的课程，其中有一门课程为java课程，我们需要打印出该课程的id、名称以及售价,为此新建一个接口类ICourse和实现类JavaCourse，JavaCourse实现接口ICours<br>
<img src="https://promonkeylee.github.io/post-images/1644461320161.png" alt="" loading="lazy"></li>
<li>此时，正好赶上节日，我们有一个促销活动，JAVA课程我们打六折</li>
</ol>
<ul>
<li>第一种选择:<br>
在ICours新增打折方法getDiscountPrice, 这种会将所有实现ICours接口的实现类都得做改变</li>
<li>第二种选择：<br>
每次打折我们都修改JavaCourse类,这种代码显然是不合理的，这样破坏了原本稳定的代码</li>
<li><strong>第三种选择：</strong><br>
新建一个JavaDiscountCourse类继承JavaCourse，并在JavaDiscountCourse新增加一个打折<br>
即可<br>
<img src="https://promonkeylee.github.io/post-images/1644461486860.png" alt="" loading="lazy"></li>
</ul>
<h2 id="2-单一职责原则">2. 单一职责原则</h2>
<h3 id="21-单一职责原则的定义">2.1 单一职责原则的定义</h3>
<p>单一职责原则又称单一功能原则，这里的职责是指类变化的原因，单一职责原则规定一个类应该有<br>
且仅有一个引起它变化的原因，否则类应该被拆分。</p>
<p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p>
<ol>
<li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li>
<li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li>
</ol>
<h3 id="22-单一职责原则的优点">2.2 单一职责原则的优点</h3>
<p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p>
<ol>
<li>降低类的复杂度</li>
<li>提高类的可读性</li>
<li>提高系统的可维护性</li>
<li>变更引起的风险降低</li>
</ol>
<h3 id="23-单一职责原则的实现方法">2.3 单一职责原则的实现方法</h3>
<p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。下面以大学学生工作管理程序为例介绍单一职责原则的应用。</p>
<p>大学学生工作管理程序:<br>
<img src="https://promonkeylee.github.io/post-images/1644461940598.png" alt="" loading="lazy"></p>
<h2 id="3接口隔离原则">3.接口隔离原则</h2>
<h3 id="31-接口隔离原则的定义">3.1 接口隔离原则的定义</h3>
<p>接口隔离原则要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p>
<p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p>
<ol>
<li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li>
<li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。<br>
** 3.2接口隔离原则的优点**<br>
接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。</li>
<li>提高系统的灵活性和可维护性</li>
<li>降低系统的耦合性。</li>
<li>保证系统的稳定性</li>
<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>
<li>能减少项目工程中的代码冗余<br>
<strong>3.3 接口隔离原则的实现方法</strong><br>
在具体应用接口隔离原则时，应该根据以下几个规则来衡量。</li>
</ol>
<ul>
<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>
<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>
<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。<br>
<strong>举例:</strong><br>
学生成绩管理程序学, 学生成绩管理程序一般包含插入成绩、删除成绩、修改成绩、计算总分、计算均<br>
分、打印成绩信息、査询成绩信息等功能，</li>
</ul>
<ol>
<li>如果将这些功能全部放到一个接口中显然不太合理<br>
<img src="https://promonkeylee.github.io/post-images/1644462585382.png" alt="" loading="lazy"></li>
<li>正确的做法是将它们分别放在输入模块、统计模块和打印模块等 3 个模块中<br>
<img src="https://promonkeylee.github.io/post-images/1644462616570.png" alt="" loading="lazy"></li>
</ol>
<h2 id="4里氏替换原则">4.里氏替换原则</h2>
<p><strong>4.1里氏替换原则的定义</strong><br>
里氏替换原则主要阐述了有关继承的一些原则。里氏替换原则是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。<strong>总结:子类可以扩展父类的功能，但不能改变父类原有的功能</strong><br>
<strong>4.2 里氏替换原则的作用</strong><br>
里氏替换原则的主要作用如下。</p>
<ol>
<li>里氏替换原则是实现开闭原则的重要方式之一。</li>
<li>它克服了继承中重写父类造成的可复用性变差的缺点。</li>
<li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>
<li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。<br>
<strong>4.3里氏替换原则的实现方法</strong><br>
根据上述理解，对里氏替换原则的定义可以总结如下：</li>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法<br>
<img src="https://promonkeylee.github.io/post-images/1644463880316.png" alt="" loading="lazy"></li>
<li>子类中可以增加自己特有的方法<br>
<img src="https://promonkeylee.github.io/post-images/1644463938170.png" alt="" loading="lazy"><br>
<img src="https://promonkeylee.github.io/post-images/1644463943366.png" alt="" loading="lazy"></li>
</ol>
<h2 id="5依赖倒置原则">5.依赖倒置原则</h2>
<h3 id="51-依赖倒置原则定义">5.1 依赖倒置原则定义</h3>
<p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依<br>
赖细节，细节应该依赖抽象。<strong>其核心思想是：要面向接口编程，不要面向实现编程。</strong></p>
<h3 id="52依赖倒置原则的作用">5.2依赖倒置原则的作用</h3>
<p>依赖倒置原则的主要作用如下。</p>
<ol>
<li>可以降低类间的耦合性。</li>
<li>可以提高系统的稳定性。</li>
<li>可以减少并行开发引起的风险。</li>
<li>可以提高代码的可读性和可维护性</li>
</ol>
<h3 id="53-依赖倒置原则的实现方法">5.3 依赖倒置原则的实现方法</h3>
<ol>
<li>依赖倒置原则在“顾客购物程序”中的应用
<ul>
<li>本程序反映了 “顾客类”与“商店类”的关系。商店类中有 sell() 方法，顾客类通过该方法购物以<br>
下代码定义了顾客类通过韶关网店 ShaoguanShop 购物：</li>
</ul>
<pre><code>class Customer {
    public void shopping(ShaoguanShop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
</code></pre>
<ul>
<li>但是，这种设计存在缺点，如果该顾客想从另外一家商店（如婺源网店 WuyuanShop）购物，就要将该顾客的代码修改如下：</li>
</ul>
<pre><code>class Customer {
    public void shopping(WuyuanShop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
</code></pre>
<ul>
<li>顾客每更换一家商店，都要修改一次代码，这明显违背了开闭原则。存在以上缺点的原因是：<br>
顾客类设计时同具体的商店类绑定了，这违背了依赖倒置原则。</li>
</ul>
<pre><code>class Customer {
    public void shopping(Shop shop) {
        //购物
        System.out.println(shop.sell());
    }
}
</code></pre>
<img src="https://promonkeylee.github.io/post-images/1644465543917.png" alt="" loading="lazy"></li>
</ol>
<h2 id="6迪米特法则">6.迪米特法则</h2>
<h3 id="61迪米特法则的定义">6.1迪米特法则的定义</h3>
<p>迪米特法则又叫作最少知识原则, 迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<h3 id="62迪米特法则的优点">6.2迪米特法则的优点</h3>
<p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p>
<ol>
<li>降低了类之间的耦合度，提高了模块的相对独立性。</li>
<li>由于亲合度降低，从而提高了类的可复用性和系统的扩展性</li>
</ol>
<h3 id="63迪米特法则的实现方法">6.3迪米特法则的实现方法</h3>
<p>从迪米特法则的定义和特点可知，它强调以下两点：</p>
<ol>
<li>从依赖者的角度来说，只依赖应该依赖的对象。</li>
<li>从被依赖者的角度说，只暴露应该暴露的方法。<br>
<strong>案例:明星与经纪人的关系实例</strong><br>
分析：明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如与粉丝的见面会，与媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则<br>
<img src="https://promonkeylee.github.io/post-images/1644466013624.png" alt="" loading="lazy"><pre><code>//经纪人    
class Agent {
        private Star myStar;
        private Fans myFans;
        private Company myCompany;
        public void setStar(Star myStar) {
            this.myStar = myStar;
        } 
        public void setFans(Fans myFans) {
            this.myFans = myFans;
        } 
        public void setCompany(Company myCompany) {
            this.myCompany = myCompany;
        } 
        public void meeting() {
            System.out.println(myFans.getName() + &quot;与明星&quot; + myStar.getName() + &quot;见面了。&quot;);
        } 
        public void business() {
            System.out.println(myCompany.getName() + &quot;与明星&quot; + myStar.getName() + &quot;洽淡业务。&quot;);
        }
} 
//明星
class Star {
    private String name;
    Star(String name) {
        this.name = name;
    } 
    public String getName() {
        return name;
    }
} 
//粉丝
class Fans {
         private String name;
    Fans(String name) {
        this.name = name;
    } 
    public String getName() {
        return name;
    }
} 
//媒体公司
class Company {
    private String name;
    Company(String name) {
        this.name = name;
    } 
    public String getName() {
        return name;
    }
} 
package principle;
public class LoDtest {
    public static void main(String[] args) {
            Agent agent = new Agent();
            agent.setStar(new Star(&quot;林心如&quot;));
            agent.setFans(new Fans(&quot;粉丝韩丞&quot;));
            agent.setCompany(new Company(&quot;中国传媒有限公司&quot;));
            agent.meeting();
            agent.business();
        }
}
</code></pre>
</li>
</ol>
<h2 id="7合成复用原则">7.合成复用原则</h2>
<h3 id="71合成复用原则的定义">7.1合成复用原则的定义</h3>
<p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则<br>
（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，<br>
两者都是开闭原则的具体实现规范。</p>
<h3 id="72合成复用原则的重要性">7.2合成复用原则的重要性</h3>
<p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p>
<ol>
<li>继承复用破坏了类的封装性</li>
<li>子类与父类的耦合度高</li>
<li>它限制了复用的灵活性<br>
采用合成复用原则时，他可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已<br>
有对象的功能，它有以下优点。</li>
<li>它维持了类的封装性</li>
<li>新旧类之间的耦合度低</li>
<li>复用的灵活性高</li>
</ol>
<h3 id="73合成复用原则的实现方法">7.3合成复用原则的实现方法</h3>
<p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已<br>
有对象的功能，从而达到复用。</p>
<p>下面以汽车分类管理程序为例来介绍合成复用原则的应用。<br>
   分析：汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。 所示是用继承关系实现的汽车分类的类图。<br>
<img src="https://promonkeylee.github.io/post-images/1644466708015.png" alt="" loading="lazy"><br>
  从上图 可以看出用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题<br>
<img src="https://promonkeylee.github.io/post-images/1644466741386.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式理论]]></title>
        <id>https://promonkeylee.github.io/post/fen-bu-shi-li-lun/</id>
        <link href="https://promonkeylee.github.io/post/fen-bu-shi-li-lun/">
        </link>
        <updated>2022-02-09T09:58:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是分布式系统">什么是分布式系统</h2>
<p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。<br>
通俗的理解，所谓分布式系统，就是一个业务拆分成多个子业务，分布在不同的服务器节点，共同构成的系统称为分布式系统，同一个分布式系统中的服务器节点在空间部署上是可以随意分布的，这些服务器可能放在不同的机柜中，也可能在不同的机房中，甚至分布在不同的城市。</p>
<h2 id="分布式与集群的区别">分布式与集群的区别</h2>
<ul>
<li>集群: 多个服务器做同一个事情</li>
<li>分布式: 多个服务器做不同的事情</li>
</ul>
<h2 id="分布式系统特性">分布式系统特性</h2>
<ol>
<li>分布性
<ul>
<li>空间中随机分布。这些计算机可以分布在不同的机房，不同的城市，甚至不同的国家。</li>
</ul>
</li>
<li>对等性
<ul>
<li>分布式系统中的计算机没有主/从之分，组成分布式系统的所有节点都是对等的。</li>
</ul>
</li>
<li>并发性
<ul>
<li>同一个分布式系统的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储。</li>
</ul>
</li>
<li>缺乏全局时钟
<ul>
<li>既然各个计算机之间是依赖于交换信息来进行相互通信，很难定义两件事件的先后顺序，缺乏全局始终控制序列</li>
</ul>
</li>
<li>故障总会发生
<ul>
<li>组成分布式的计算机，都有可能在某一时刻突然间崩掉。分的计算机越多，可能崩掉一个的几率就越大。如果再考虑到设计程序时的异常故障，也会加大故障的概率。</li>
</ul>
</li>
<li>处理单点故障
<ul>
<li>单点SPoF（Single Point of Failure）：某个角色或者功能只有某一台计算机在支撑，在这台计算机上出现的故障是单点故障</li>
</ul>
</li>
</ol>
<h2 id="分布式系统面临的问题">分布式系统面临的问题</h2>
<ol>
<li>通信异常</li>
<li>网络分区</li>
<li>节点故障</li>
<li>三态(成功、失败和超时)</li>
<li>重发</li>
<li>幂等</li>
</ol>
<h2 id="数据一致性">数据一致性</h2>
<ol>
<li>强一致性</li>
<li>弱一致性</li>
<li>最终一致性
<ul>
<li>因果一致性</li>
<li>读己之所写一致性</li>
<li>会话一致性</li>
<li>单调读一致性</li>
<li>单调写一致性</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>一致性模型图</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644401031723.png" alt="" loading="lazy"></p>
</blockquote>
<h2 id="cap定理">CAP定理</h2>
<p>CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点</p>
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>具体意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>一致性（Consistency）</td>
<td>所有节点访问时都是同一份最新的数据副本</td>
</tr>
<tr>
<td>可用性（Availability）</td>
<td>每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据</td>
</tr>
<tr>
<td>分区容错性（Partitiontolerance）</td>
<td>分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RPC框架]]></title>
        <id>https://promonkeylee.github.io/post/rpc-kuang-jia/</id>
        <link href="https://promonkeylee.github.io/post/rpc-kuang-jia/">
        </link>
        <updated>2022-02-08T10:53:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分布式架构网络通信"><strong>分布式架构网络通信</strong></h2>
<p>在分布式服务框架中，一个最基础的问题就是远程服务是怎么通讯的，在Java领域中有很多可实现远程通讯的技术，例如：RMI、Hessian、SOAP、ESB和JMS等，它们背后到底是基于什么原理实现的呢？</p>
<h3 id="基本原理"><strong>基本原理</strong></h3>
<p>要实现网络机器间的通讯，首先得来看看计算机系统网络通信的基本原理，在底层层面去看，网络通信需要做的就是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、aio三种方式，所有的分布式应用通讯都基于这个原理而实现</p>
<h3 id="什么是rpc"><strong>什么是RPC</strong></h3>
<p>RPC全称为remote procedure call，即远程过程调用。借助RPC可以做到像本地调用一样调用远程服<br>
务，是一种进程间的通信方式.</p>
<p>比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。<strong>需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。</strong><br>
<img src="https://promonkeylee.github.io/post-images/1644318052798.png" alt="" loading="lazy"></p>
<h3 id="rpc架构"><strong>RPC架构</strong></h3>
<p>一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。</p>
<blockquote>
<ul>
<li>客户端(Client)，服务的调用方。</li>
<li>客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li>
<li>服务端(Server)，真正的服务提供者。</li>
<li>服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li>
</ul>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://promonkeylee.github.io/post-images/1644318278407.png" alt="" loading="lazy"></figure>
<ol>
<li>客户端（client）以本地调用方式（即以接口的方式）调用服务；</li>
<li>客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；</li>
<li>客户端通过socket将消息发送到服务端；</li>
<li>服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）；</li>
<li>服务端存根( server stub）根据解码结果调用本地的服务；</li>
<li>服务处理</li>
<li>本地服务执行并将结果返回给服务端存根( server stub）；</li>
<li>服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；</li>
<li>服务端（server）通过socket将消息发送到客户端；</li>
<li>客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；</li>
<li>客户端（client）得到最终结果。</li>
</ol>
<p>RPC的目标是要把2、3、4、5、7、8、9、10这些步骤都封装起来。只剩下1、6、11</p>
<blockquote>
<p>注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。</p>
</blockquote>
<p>在java中RPC框架比较多，常见的有Hessian、gRPC、Dubbo 等，其实对 于RPC框架而言，核心模块就是<strong>通讯和序列化</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[事务传播行为]]></title>
        <id>https://promonkeylee.github.io/post/shi-wu-chuan-bo-xing-wei/</id>
        <link href="https://promonkeylee.github.io/post/shi-wu-chuan-bo-xing-wei/">
        </link>
        <updated>2022-02-07T01:51:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
</blockquote>
<p><img src="https://promonkeylee.github.io/post-images/1644198765503.png" alt="" loading="lazy"><br>
<img src="https://promonkeylee.github.io/post-images/1644199052542.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>